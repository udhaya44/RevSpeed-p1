import { ChangeDetectionStrategy, Component, HostBinding, inject, Input, ViewEncapsulation } from '@angular/core';
import { getValueInRange, isNumber } from '../util/util';
import { NgbProgressbarConfig } from './progressbar-config';
import { PercentPipe } from '@angular/common';
import * as i0 from "@angular/core";
/**
 * A directive that provides feedback on the progress of a workflow or an action.
 */
export class NgbProgressbar {
    /**
     * The maximal value to be displayed in the progress bar.
     *
     * Should be a positive number. Will default to 100 otherwise.
     */
    set max(max) {
        this._max = !isNumber(max) || max <= 0 ? 100 : max;
    }
    get max() {
        return this._max;
    }
    constructor() {
        this._config = inject(NgbProgressbarConfig);
        this.stacked = inject(NgbProgressbarStacked, { optional: true });
        /**
         * If `true`, the stripes on the progress bar are animated.
         *
         * Takes effect only for browsers supporting CSS3 animations, and if `striped` is `true`.
         */
        this.animated = this._config.animated;
        /**
         * The accessible progress bar name.
         *
         * @since 13.1.0
         */
        this.ariaLabel = this._config.ariaLabel;
        /**
         * If `true`, the progress bars will be displayed as striped.
         */
        this.striped = this._config.striped;
        /**
         * If `true`, the current percentage will be shown in the `xx%` format.
         */
        this.showValue = this._config.showValue;
        /**
         * Optional text variant type of the progress bar.
         *
         * Supports types based on Bootstrap background color variants, like:
         *  `"success"`, `"info"`, `"warning"`, `"danger"`, `"primary"`, `"secondary"`, `"dark"` and so on.
         *
         * @since 5.2.0
         */
        this.textType = this._config.textType;
        /**
         * The type of the progress bar.
         *
         * Supports types based on Bootstrap background color variants, like:
         *  `"success"`, `"info"`, `"warning"`, `"danger"`, `"primary"`, `"secondary"`, `"dark"` and so on.
         */
        this.type = this._config.type;
        /**
         * The current value for the progress bar.
         *
         * Should be in the `[0, max]` range.
         */
        this.value = 0;
        /**
         * The height of the progress bar.
         *
         * Accepts any valid CSS height values, ex. `"2rem"`
         */
        this.height = this._config.height;
        this.max = this._config.max;
    }
    getValue() {
        return getValueInRange(this.value, this.max);
    }
    getPercentValue() {
        return (100 * this.getValue()) / this.max;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: NgbProgressbar, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.0.0", type: NgbProgressbar, isStandalone: true, selector: "ngb-progressbar", inputs: { max: "max", animated: "animated", ariaLabel: "ariaLabel", striped: "striped", showValue: "showValue", textType: "textType", type: "type", value: "value", height: "height" }, host: { attributes: { "role": "progressbar", "aria-valuemin": "0" }, properties: { "attr.aria-valuenow": "getValue()", "attr.aria-valuemax": "max", "attr.aria-label": "ariaLabel", "style.width.%": "stacked ? getPercentValue() : null", "style.height": "this.height" }, classAttribute: "progress" }, ngImport: i0, template: `
		<div
			class="progress-bar{{ type ? (textType ? ' bg-' + type : ' text-bg-' + type) : '' }}{{
				textType ? ' text-' + textType : ''
			}}"
			[class.progress-bar-animated]="animated"
			[class.progress-bar-striped]="striped"
			[style.width.%]="!stacked ? getPercentValue() : null"
		>
			@if (showValue) {
				<span i18n="@@ngb.progressbar.value">{{ getValue() / max | percent }}</span>
			}
			<ng-content />
		</div>
	`, isInline: true, dependencies: [{ kind: "pipe", type: PercentPipe, name: "percent" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: NgbProgressbar, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngb-progressbar',
                    standalone: true,
                    imports: [PercentPipe],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        class: 'progress',
                        role: 'progressbar',
                        '[attr.aria-valuenow]': 'getValue()',
                        'aria-valuemin': '0',
                        '[attr.aria-valuemax]': 'max',
                        '[attr.aria-label]': 'ariaLabel',
                        '[style.width.%]': 'stacked ? getPercentValue() : null',
                    },
                    template: `
		<div
			class="progress-bar{{ type ? (textType ? ' bg-' + type : ' text-bg-' + type) : '' }}{{
				textType ? ' text-' + textType : ''
			}}"
			[class.progress-bar-animated]="animated"
			[class.progress-bar-striped]="striped"
			[style.width.%]="!stacked ? getPercentValue() : null"
		>
			@if (showValue) {
				<span i18n="@@ngb.progressbar.value">{{ getValue() / max | percent }}</span>
			}
			<ng-content />
		</div>
	`,
                }]
        }], ctorParameters: () => [], propDecorators: { max: [{
                type: Input
            }], animated: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], striped: [{
                type: Input
            }], showValue: [{
                type: Input
            }], textType: [{
                type: Input
            }], type: [{
                type: Input
            }], value: [{
                type: Input,
                args: [{ required: true }]
            }], height: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['style.height']
            }] } });
/**
 * A directive that allow to stack progress bars.
 *
 * @since 16.0.0
 */
export class NgbProgressbarStacked {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: NgbProgressbarStacked, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.0", type: NgbProgressbarStacked, isStandalone: true, selector: "ngb-progressbar-stacked", host: { classAttribute: "progress-stacked" }, ngImport: i0, template: `<ng-content></ng-content>`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: NgbProgressbarStacked, decorators: [{
            type: Component,
            args: [{
                    selector: 'ngb-progressbar-stacked',
                    standalone: true,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        class: 'progress-stacked',
                    },
                    template: `<ng-content></ng-content>`,
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNsSCxPQUFPLEVBQUUsZUFBZSxFQUFFLFFBQVEsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0saUJBQWlCLENBQUM7O0FBRTlDOztHQUVHO0FBZ0NILE1BQU0sT0FBTyxjQUFjO0lBSzFCOzs7O09BSUc7SUFDSCxJQUNJLEdBQUcsQ0FBQyxHQUFXO1FBQ2xCLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFDcEQsQ0FBQztJQUVELElBQUksR0FBRztRQUNOLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNsQixDQUFDO0lBMEREO1FBMUVRLFlBQU8sR0FBRyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUN4QyxZQUFPLEdBQUcsTUFBTSxDQUFDLHFCQUFxQixFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFpQm5FOzs7O1dBSUc7UUFDTSxhQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7UUFFMUM7Ozs7V0FJRztRQUNNLGNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUU1Qzs7V0FFRztRQUNNLFlBQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUV4Qzs7V0FFRztRQUNNLGNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUU1Qzs7Ozs7OztXQU9HO1FBQ00sYUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDO1FBRTFDOzs7OztXQUtHO1FBQ00sU0FBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBRWxDOzs7O1dBSUc7UUFDd0IsVUFBSyxHQUFHLENBQUMsQ0FBQztRQUVyQzs7OztXQUlHO1FBQ21DLFdBQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztRQUdsRSxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0lBQzdCLENBQUM7SUFFRCxRQUFRO1FBQ1AsT0FBTyxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELGVBQWU7UUFDZCxPQUFPLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDM0MsQ0FBQzs4R0FyRlcsY0FBYztrR0FBZCxjQUFjLDZpQkFoQmhCOzs7Ozs7Ozs7Ozs7OztFQWNULHVEQTFCUyxXQUFXOzsyRkE0QlQsY0FBYztrQkEvQjFCLFNBQVM7bUJBQUM7b0JBQ1YsUUFBUSxFQUFFLGlCQUFpQjtvQkFDM0IsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLE9BQU8sRUFBRSxDQUFDLFdBQVcsQ0FBQztvQkFDdEIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO29CQUNyQyxJQUFJLEVBQUU7d0JBQ0wsS0FBSyxFQUFFLFVBQVU7d0JBQ2pCLElBQUksRUFBRSxhQUFhO3dCQUNuQixzQkFBc0IsRUFBRSxZQUFZO3dCQUNwQyxlQUFlLEVBQUUsR0FBRzt3QkFDcEIsc0JBQXNCLEVBQUUsS0FBSzt3QkFDN0IsbUJBQW1CLEVBQUUsV0FBVzt3QkFDaEMsaUJBQWlCLEVBQUUsb0NBQW9DO3FCQUN2RDtvQkFDRCxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7O0VBY1Q7aUJBQ0Q7d0RBWUksR0FBRztzQkFETixLQUFLO2dCQWNHLFFBQVE7c0JBQWhCLEtBQUs7Z0JBT0csU0FBUztzQkFBakIsS0FBSztnQkFLRyxPQUFPO3NCQUFmLEtBQUs7Z0JBS0csU0FBUztzQkFBakIsS0FBSztnQkFVRyxRQUFRO3NCQUFoQixLQUFLO2dCQVFHLElBQUk7c0JBQVosS0FBSztnQkFPcUIsS0FBSztzQkFBL0IsS0FBSzt1QkFBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUU7Z0JBT2EsTUFBTTtzQkFBM0MsS0FBSzs7c0JBQUksV0FBVzt1QkFBQyxjQUFjOztBQWVyQzs7OztHQUlHO0FBV0gsTUFBTSxPQUFPLHFCQUFxQjs4R0FBckIscUJBQXFCO2tHQUFyQixxQkFBcUIsaUlBRnZCLDJCQUEyQjs7MkZBRXpCLHFCQUFxQjtrQkFWakMsU0FBUzttQkFBQztvQkFDVixRQUFRLEVBQUUseUJBQXlCO29CQUNuQyxVQUFVLEVBQUUsSUFBSTtvQkFDaEIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO29CQUNyQyxJQUFJLEVBQUU7d0JBQ0wsS0FBSyxFQUFFLGtCQUFrQjtxQkFDekI7b0JBQ0QsUUFBUSxFQUFFLDJCQUEyQjtpQkFDckMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBIb3N0QmluZGluZywgaW5qZWN0LCBJbnB1dCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGdldFZhbHVlSW5SYW5nZSwgaXNOdW1iZXIgfSBmcm9tICcuLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgTmdiUHJvZ3Jlc3NiYXJDb25maWcgfSBmcm9tICcuL3Byb2dyZXNzYmFyLWNvbmZpZyc7XG5pbXBvcnQgeyBQZXJjZW50UGlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBwcm92aWRlcyBmZWVkYmFjayBvbiB0aGUgcHJvZ3Jlc3Mgb2YgYSB3b3JrZmxvdyBvciBhbiBhY3Rpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogJ25nYi1wcm9ncmVzc2JhcicsXG5cdHN0YW5kYWxvbmU6IHRydWUsXG5cdGltcG9ydHM6IFtQZXJjZW50UGlwZV0sXG5cdGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuXHRlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuXHRob3N0OiB7XG5cdFx0Y2xhc3M6ICdwcm9ncmVzcycsXG5cdFx0cm9sZTogJ3Byb2dyZXNzYmFyJyxcblx0XHQnW2F0dHIuYXJpYS12YWx1ZW5vd10nOiAnZ2V0VmFsdWUoKScsXG5cdFx0J2FyaWEtdmFsdWVtaW4nOiAnMCcsXG5cdFx0J1thdHRyLmFyaWEtdmFsdWVtYXhdJzogJ21heCcsXG5cdFx0J1thdHRyLmFyaWEtbGFiZWxdJzogJ2FyaWFMYWJlbCcsXG5cdFx0J1tzdHlsZS53aWR0aC4lXSc6ICdzdGFja2VkID8gZ2V0UGVyY2VudFZhbHVlKCkgOiBudWxsJyxcblx0fSxcblx0dGVtcGxhdGU6IGBcblx0XHQ8ZGl2XG5cdFx0XHRjbGFzcz1cInByb2dyZXNzLWJhcnt7IHR5cGUgPyAodGV4dFR5cGUgPyAnIGJnLScgKyB0eXBlIDogJyB0ZXh0LWJnLScgKyB0eXBlKSA6ICcnIH19e3tcblx0XHRcdFx0dGV4dFR5cGUgPyAnIHRleHQtJyArIHRleHRUeXBlIDogJydcblx0XHRcdH19XCJcblx0XHRcdFtjbGFzcy5wcm9ncmVzcy1iYXItYW5pbWF0ZWRdPVwiYW5pbWF0ZWRcIlxuXHRcdFx0W2NsYXNzLnByb2dyZXNzLWJhci1zdHJpcGVkXT1cInN0cmlwZWRcIlxuXHRcdFx0W3N0eWxlLndpZHRoLiVdPVwiIXN0YWNrZWQgPyBnZXRQZXJjZW50VmFsdWUoKSA6IG51bGxcIlxuXHRcdD5cblx0XHRcdEBpZiAoc2hvd1ZhbHVlKSB7XG5cdFx0XHRcdDxzcGFuIGkxOG49XCJAQG5nYi5wcm9ncmVzc2Jhci52YWx1ZVwiPnt7IGdldFZhbHVlKCkgLyBtYXggfCBwZXJjZW50IH19PC9zcGFuPlxuXHRcdFx0fVxuXHRcdFx0PG5nLWNvbnRlbnQgLz5cblx0XHQ8L2Rpdj5cblx0YCxcbn0pXG5leHBvcnQgY2xhc3MgTmdiUHJvZ3Jlc3NiYXIge1xuXHRwcml2YXRlIF9jb25maWcgPSBpbmplY3QoTmdiUHJvZ3Jlc3NiYXJDb25maWcpO1xuXHRwdWJsaWMgc3RhY2tlZCA9IGluamVjdChOZ2JQcm9ncmVzc2JhclN0YWNrZWQsIHsgb3B0aW9uYWw6IHRydWUgfSk7XG5cdHByaXZhdGUgX21heDogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBUaGUgbWF4aW1hbCB2YWx1ZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIHByb2dyZXNzIGJhci5cblx0ICpcblx0ICogU2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLiBXaWxsIGRlZmF1bHQgdG8gMTAwIG90aGVyd2lzZS5cblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCBtYXgobWF4OiBudW1iZXIpIHtcblx0XHR0aGlzLl9tYXggPSAhaXNOdW1iZXIobWF4KSB8fCBtYXggPD0gMCA/IDEwMCA6IG1heDtcblx0fVxuXG5cdGdldCBtYXgoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4O1xuXHR9XG5cblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgdGhlIHN0cmlwZXMgb24gdGhlIHByb2dyZXNzIGJhciBhcmUgYW5pbWF0ZWQuXG5cdCAqXG5cdCAqIFRha2VzIGVmZmVjdCBvbmx5IGZvciBicm93c2VycyBzdXBwb3J0aW5nIENTUzMgYW5pbWF0aW9ucywgYW5kIGlmIGBzdHJpcGVkYCBpcyBgdHJ1ZWAuXG5cdCAqL1xuXHRASW5wdXQoKSBhbmltYXRlZCA9IHRoaXMuX2NvbmZpZy5hbmltYXRlZDtcblxuXHQvKipcblx0ICogVGhlIGFjY2Vzc2libGUgcHJvZ3Jlc3MgYmFyIG5hbWUuXG5cdCAqXG5cdCAqIEBzaW5jZSAxMy4xLjBcblx0ICovXG5cdEBJbnB1dCgpIGFyaWFMYWJlbCA9IHRoaXMuX2NvbmZpZy5hcmlhTGFiZWw7XG5cblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgdGhlIHByb2dyZXNzIGJhcnMgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgc3RyaXBlZC5cblx0ICovXG5cdEBJbnB1dCgpIHN0cmlwZWQgPSB0aGlzLl9jb25maWcuc3RyaXBlZDtcblxuXHQvKipcblx0ICogSWYgYHRydWVgLCB0aGUgY3VycmVudCBwZXJjZW50YWdlIHdpbGwgYmUgc2hvd24gaW4gdGhlIGB4eCVgIGZvcm1hdC5cblx0ICovXG5cdEBJbnB1dCgpIHNob3dWYWx1ZSA9IHRoaXMuX2NvbmZpZy5zaG93VmFsdWU7XG5cblx0LyoqXG5cdCAqIE9wdGlvbmFsIHRleHQgdmFyaWFudCB0eXBlIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG5cdCAqXG5cdCAqIFN1cHBvcnRzIHR5cGVzIGJhc2VkIG9uIEJvb3RzdHJhcCBiYWNrZ3JvdW5kIGNvbG9yIHZhcmlhbnRzLCBsaWtlOlxuXHQgKiAgYFwic3VjY2Vzc1wiYCwgYFwiaW5mb1wiYCwgYFwid2FybmluZ1wiYCwgYFwiZGFuZ2VyXCJgLCBgXCJwcmltYXJ5XCJgLCBgXCJzZWNvbmRhcnlcImAsIGBcImRhcmtcImAgYW5kIHNvIG9uLlxuXHQgKlxuXHQgKiBAc2luY2UgNS4yLjBcblx0ICovXG5cdEBJbnB1dCgpIHRleHRUeXBlID0gdGhpcy5fY29uZmlnLnRleHRUeXBlO1xuXG5cdC8qKlxuXHQgKiBUaGUgdHlwZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuXHQgKlxuXHQgKiBTdXBwb3J0cyB0eXBlcyBiYXNlZCBvbiBCb290c3RyYXAgYmFja2dyb3VuZCBjb2xvciB2YXJpYW50cywgbGlrZTpcblx0ICogIGBcInN1Y2Nlc3NcImAsIGBcImluZm9cImAsIGBcIndhcm5pbmdcImAsIGBcImRhbmdlclwiYCwgYFwicHJpbWFyeVwiYCwgYFwic2Vjb25kYXJ5XCJgLCBgXCJkYXJrXCJgIGFuZCBzbyBvbi5cblx0ICovXG5cdEBJbnB1dCgpIHR5cGUgPSB0aGlzLl9jb25maWcudHlwZTtcblxuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgdmFsdWUgZm9yIHRoZSBwcm9ncmVzcyBiYXIuXG5cdCAqXG5cdCAqIFNob3VsZCBiZSBpbiB0aGUgYFswLCBtYXhdYCByYW5nZS5cblx0ICovXG5cdEBJbnB1dCh7IHJlcXVpcmVkOiB0cnVlIH0pIHZhbHVlID0gMDtcblxuXHQvKipcblx0ICogVGhlIGhlaWdodCBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuXHQgKlxuXHQgKiBBY2NlcHRzIGFueSB2YWxpZCBDU1MgaGVpZ2h0IHZhbHVlcywgZXguIGBcIjJyZW1cImBcblx0ICovXG5cdEBJbnB1dCgpIEBIb3N0QmluZGluZygnc3R5bGUuaGVpZ2h0JykgaGVpZ2h0ID0gdGhpcy5fY29uZmlnLmhlaWdodDtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLm1heCA9IHRoaXMuX2NvbmZpZy5tYXg7XG5cdH1cblxuXHRnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gZ2V0VmFsdWVJblJhbmdlKHRoaXMudmFsdWUsIHRoaXMubWF4KTtcblx0fVxuXG5cdGdldFBlcmNlbnRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gKDEwMCAqIHRoaXMuZ2V0VmFsdWUoKSkgLyB0aGlzLm1heDtcblx0fVxufVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgYWxsb3cgdG8gc3RhY2sgcHJvZ3Jlc3MgYmFycy5cbiAqXG4gKiBAc2luY2UgMTYuMC4wXG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogJ25nYi1wcm9ncmVzc2Jhci1zdGFja2VkJyxcblx0c3RhbmRhbG9uZTogdHJ1ZSxcblx0Y2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG5cdGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG5cdGhvc3Q6IHtcblx0XHRjbGFzczogJ3Byb2dyZXNzLXN0YWNrZWQnLFxuXHR9LFxuXHR0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gLFxufSlcbmV4cG9ydCBjbGFzcyBOZ2JQcm9ncmVzc2JhclN0YWNrZWQge31cbiJdfQ==